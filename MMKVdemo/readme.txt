IOBridge.write()
IOBridge用于，用户空间（应用层）与内核空间数据交互

File的操作、流的操作FileOutputStream等本质都是IO操作，需要IOBridge作为桥梁，用户空间与内核空间交互是进程间通信，需要进程间的上下文切换，是很耗时的操作。

SharePreference就是File流的操作，将key、value写到一个xml里，读取数据时解析xml也是一个耗时操作，所以sp是比较耗时的。

SP的可优化点：
1、IO操作耗时
2、dom解析耗时
3、sp.xml存储更耗磁盘空间, 可通过可变长编码（哈夫曼、哥伦布等编码方式）优化，protubuf

MMU：内存管理单元、是一个硬件设备
用来管理虚拟存储器、物理储存器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权、多任务多进程操作系统。
主要作用，是将cpu里的虚拟地址 与 内存中的物理地址 产生映射。

现代程序具有局部性原则：
只有活跃的代码加载到物理内存中（物理内存资源宝贵），其余代码在磁盘上。

页：1页4k
是mmu数据交换的最小单位

页未命中：
假如cpu执行一个变量a，但重来没有执行过这个变量，mmu里映射的物理内存里也没有变量a，此时就是页未命中；直到从磁盘里将变量a加载到物理内存，cpu再执行一遍这个过程，发现内存地址有了a，此时就是页命中了。

mmap函数：
让物理内存 与 磁盘之间产生映射，物理地址值变了实时同步到磁盘。

MMKV问题：
1. 写的时候不会覆盖相同的key，会存入多个相同的数据，这样做的目的是为了写的时候不去遍历key，以提高写入的速度；导致的问题是可能增大存储空间，mmkv的解决方案是在每次4k页对齐时需要重新分配内存，在这个过程中就将老数据复写到重新分配的空间，同时剔除掉重复数据，有效避免内存额外增大问题。
2. 读的时候，怎么读取重复数据，全量遍历取最后一个吗？那也是比较耗时的；mmkv巧妙的技巧是，提供一个hashmap，取出的数据重复的就放入map替换掉，应用层与map交互就很快了，也就避免了全量遍历，不得不说是很巧妙的设计。
